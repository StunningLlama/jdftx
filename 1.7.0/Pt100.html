<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JDFTx: Pt(100) setup</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Pt100.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Pt(100) setup </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="Pt100.png" alt=""/>
</div>
<p>For (100) surfaces, the surface normal is along a (100) direction i.e. the cube axes. For a cubic system, all three axes are equivalent and we will pick the surface normal along the z direction.</p>
<p>Thhe first step is to find a supercell consisting of layers parallel to the surface. The supercell lattice vectors are integer linear combinations of the original lattice vectors. Specifically, we need to find the smallest integer linear combinations that satisfy:</p>
<ol type="1">
<li>Two superlattice vectors are perpendicular to the surface normal (i.e. in-plane)</li>
<li>The third superlattice vector is parallel to the surface normal</li>
</ol>
<p>Once again, the original face-centered cubic lattice vectors (in columns) are: </p><pre class="fragment">    /  0  a/2 a/2 \
R = | a/2  0  a/2 |
    \ a/2 a/2  0  /
</pre><p> For the 100 surface, we can get a superlattice vector along the z direction by adding the first two columns and subtracting the last column, which corresponds to a linear combination [ 1 1 -1 ]. We now need two linearly-independent superlattice vectors with no z component. The third column i.e. combination [ 0 0 1] already satisfies this criterion, and we can get another from the difference of the first two lattice vectors i.e. the linear combination [ 1 -1 0 ]. Putting these linear combination together <em>along columns</em>, we get the lattice transformation matrix: </p><pre class="fragment">    / 0  1  1 \
M = | 0 -1  1 |
    \ 1  0 -1 /
</pre><p> Multiplying the original lattice vectors R by this transformation matrix, we would get the superlattice vectors: </p><pre class="fragment">               /  0  a/2 a/2 \   / 0  1  1 \   / a/2 -a/2  0 \
Rsup = R . M = | a/2  0  a/2 | . | 0 -1  1 | = | a/2  a/2  0 |
               \ a/2 a/2  0  /   \ 1  0 -1 /   \  0    0   a /
</pre><p> Note that these superlattice vectors are all perpendicular to each other, with the first two in the x-y plane and the third along z, as desired. The absolute orientation of the lattice vectors in space do not matter, we only need to preserve their lengths and the angles between them. Specifically the above is a tetragonal lattice with square side a/sqrt(2) and height a, which we could specify using a shorthand in JDFTx as </p><pre class="fragment">latttice Tetragonal ${aBySqrt2} ${a}  #With a/sqrt(2) and a set previously
</pre><p> The determinant of the transformation matrix, det(M) = 2, which means that det(Rsup) = 2 det(R), or that the volume of the supercell is twice that of the unit cell. Therefore we would need two atoms per supercell, to get the original crystal again. We can leave the first atom at fractional coordinates [ 0 0 0 ] in the unit cell. We can add the second atom at any of the original lattice vectors which has a non-zero component along the surface normal direction.= eg. [ 1 0 0 ] in the unit cell. Now we need to transform these fractional coordinates from the unit cell to the supercell, using the inverse of the transformation matrix, inv(M). The first atom coordinates [ 0 0 0] of course transform to [ 0 0 0 ], and for the second atom, the new coordinates are: </p><pre class="fragment">         / 1 \    / 1/2  1/2  1 \   / 1 \   / 1/2 \
inv(M) . | 0 | =  | 1/2 -1/2  0 | . | 0 | = | 1/2 |
         \ 0 /    \ 1/2  1/2  0 /   \ 0 /   \ 1/2 /
</pre><p> Therefore, the fractional atom coordinates for the supercell can be specified as: </p><pre class="fragment">ion Pt  0.0  0.0  0.0   1
ion Pt  0.5  0.5  0.5   1
</pre><p> At this stage, we have the lattice and ionpos for a supercell calculation. Running JDFTx on this geometry (with appropriate k-point sampling etc.) would give you exactly the same material properties as on the original unit cell, except that extensive properties like the total energy would be twice as large since there are two atoms per unit cell (try it).</p>
<p>Our current supercell has two layers with a 100 surface direction. The next step is to increase the number of layers, and cleave the crystal by adding some gap along the to-be non-periodic third direction. Let's say we want 5 atomic layers, and a minimum gap of 15 bohrs as before. The layer spacing is a/2 (third supercell lattice vector has length a, and there are two layers per supercell so far) = 3.705 bohrs, so 5 empty atomic layers is the minimum number &gt; 15 bohrs of spacing. Therefore we pick a supercell that has 10 atomic layers i.e. five times as before. For this, we scale up our third lattice vector by five: </p><pre class="fragment">#Save the following to 100.lattice:
lattice Tetragonal 5.23966 37.05    #a/sqrt(2) and 5a in bohrs, respectively
</pre><p> The third fractional coordinates of the atom would then scale down by a factor of five: </p><pre class="fragment">ion Pt  0.0  0.0  0.0   1
ion Pt  0.5  0.5  0.1   1
</pre><p> and we need to repeat this with offsets of 1/5, 2/5 etc. along the third direction. This would produce layers with the third coordinate ranging from 0.0 to 0.9; using periodiocity we can wrap third coordinates in the range [0.5,1) to the range [-0.5,0). Finally, selecting the central five layers, we arrive at the coordinates: </p><pre class="fragment">#Save the following to 100.ionpos:
ion Pt  0.0  0.0 -0.2   1
ion Pt  0.5  0.5 -0.1   1
ion Pt  0.0  0.0  0.0   1
ion Pt  0.5  0.5  0.1   1
ion Pt  0.0  0.0  0.2   1
</pre><p> We can quickly test the geometry without running a full calculation. Setup a dummy input file: </p><pre class="fragment">#Save the following to testGeometry.in
include ${surface}.lattice   #we will use the same input file later for 110 and 111
include ${surface}.ionpos
ion-species GBRV/$ID_pbe.uspp
#Not a real calculation; missing kpoints and fillings!
</pre><p> and run JDFTx using the dry-run (-n) commandline switch: </p><pre class="fragment">export surface="100"   #or "110" or "111" later on
jdftx -ni testGeometry.in | tee testGeometry-${surface}.out
</pre><p> Examine the output file: it performs initialization and quits. We can create an XSF file even from this initialization-only output file as usual: </p><pre class="fragment">createXSF testGeometry-${surface}.out ${surface}.xsf
</pre><p> and visualize 100.xsf using VESTA to get an image as shown at the top of the page.</p>
<p>Note that you should adjust the boundary settings, particularly for the z direction to [-0.5,0.5), in order to not tear the visualization across periodic boundaries. You could also repeat the x and y directions by more units say [0,2) or [0,3) to more clearly see the surfce structure (not included in the image shown above). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
